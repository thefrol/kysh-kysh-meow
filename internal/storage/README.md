# Хранилище метрик

Содержит хранилище для памяти `MemStore`, типы счетчиков `Counter`, `Gauge` и интерфейс `Storager`

## `Storager` - интерфейс хранилища

Сделан в стиле языка `Go`, метрики вызываются геттерами и сеттерами

```go
val,ok:=storage.Counter("testCounter")
storage.SetCounter("testCounter", val)
// и аналогично Gauge, SetGauge
```

Если добавлять тип, нужно создавать новый интерфейс и новый тип, и ещё имплементировать Stringer для типа
```go
type NewType newtype

type NewTyper interface{
	NewTyper(name string)
	SetNewTyper(name string, value NewType)
}

func (n NewType) String() string{

}// NewType должен поддерживать интерфейс Stringer теперь
```

И ещё добавить в конструктор, и ещё добавить поля в `MemStore`, короче тоже не просто все

В целом есть ощущение, что если уж мы создали наименование функций, то именованные типы (`Counter` вместо `int64`) кажутся **лишними**


# Исследование

Мне кажется, надо понимать, что рано или поздно мы переедем в базу данных, а значит надо 
+ Пользоваться интерфейсом для хранилища
+ Организовывать данные соответсвенно

Возможно в функцию мы будем получать интерфейс сохранения объекта, но без указания в какой базе мы его держим

## Хранилище никак не знает ни о чем, оно умеет только хранить.

### Хранилище только для одного типа данных. В марштрут мы передаем хранилище

```go
makeroute("/counter", NewStorage[int64](), counterHandler)

func counterHandler(storage,urlArgs){
	val=storage.ParseValue(string_from_request)
	storage.Add("name",val)
}
```

Тут можно использовать `Дженерики`

----

В итоге оказывается, что мы не можем передать дженерик интерфейс в функцию так `func Foo(s store)`, нам обязательно требудется указать тип так `func Foo(s store[int64])`, иначе будет ошибка на неиниализированный интерфейс. А это значит что для каждого маршрута придётся писать свою функцию обработчик со своей сигнатурой.

Или... подождите подождите, это должна быть дженерик функция тоже, такого типа

```go
func makeHandler(T any)(){
	return func(s[storage], w http.RepsonseWriter, r *http.Request)
}
```

А ведь неплохой вариант, блин. Единственное, непонятно, что будет когда доедем до базы данных. Видимо базе придется какие-то Dao-объекты делать для кадого типа, содержащие в себе замыкания... **Красиво, можно было бы попробовать.** 

### Хранилище хранит разные типы данных, по сути нам нужен интерфейсный тип для данных, это гемор


```go
//использование Counter
Metric.Set[counter]()
Metric.Add[counter]()
Metric.Get[counter]()

//Хендлер маршрута
counterHandler():
	old_val,ok=storage["counter"]["testCounter"]
	storage["counter"]["testCounter"]=new(Counter)

```

Тут придется использовать `Интерфейсы`

> А можно написать и несколько версий-веток!

----
Тут главная проблема, что в интерфейсе не может быть дженерик методово, может быть дженерик только сам интерфейс
Это значит нужно или писать интерфейс для метрики, а её тоже потребуется инициализировать. Мы знаем только метод `SetString(valueFromRequest string)`,
который можно имплементировать без приведения типа, а где-то все равно придётся приводить тип из интерфейса 


Нужно не забывать, что ещё существует задача проверки типа счетчика, когда приходит запрос, это ещё дополнительная загвозка 

## Заключение

Мне кажется интересным способом было бы ещё воспользоваться паттерном из w.ResponseWriter()

```
w. Header().Write()
w.Header().Get()
```

так у нас могло бы быть `storage.Counter().Get()`, где 

```
func (m MemStorage) Counter() MetricStorage(int64){
	...
}

type MetricStorage[T any] interface{
	Get() T
	Set(val T)
	Add(val T)
}

```

Получается такой гибрид итоговорого способа и первого экспериментального и раздела Исследование

----

Ещё один момент, по сути метрики это не только тип данных, но ещё и поведение, и конечно стоило бы выделить их в отдельный пакет, конечно, чтобы у них была функция вроде Process

metrics.Counter()
