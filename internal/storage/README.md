# Хранилище метрик

Содержит хранилище для памяти `MemStore`, типы счетчиков `Counter`, `Gauge` и интерфейс `Storager`

## Обновление 10.1

### Тест скорости

Короче я провел исследование. Померил скорость, и оказывается, что, если мы не будем лишний раз проверять типы данных в запросе(поле `MType`), то это нам сэкономит *несколько наносекунд*. Этого очень мало. Такая оптимизация будет иметь смысл, только когда количество запросов перевалит за миллиард. Да даже в таком случае станет разница в две секунды.

В реальных условиях, может работать по разному, то тут то там быстрее. Или оптимизированная быстрее или наборот, - видимо из-за особенностей запусков контекстов и переключений между потоками, так что **не стоит тратить свою жизнь на оптимизацию нескольких наносекунд**, которые и то игрушка ~~дьявола~~ планировщика потоков.

### Хендлеры

Очень странная ситуация возникла, что в хендлерах мы оперируем очень далекими от хендлеров классами - `Counter` и `Gauge`. Это создает кучу проблем с преобразованием типов. Хотя бы глянуть сюда

```go
old, _ := api.store.Counter(params.name)
new := old + metrica.Counter(value)
api.store.SetCounter(params.name, new)
```

Спроси у человека, что делает код, и он выпадет в осадок. Потом пять минут потупит, поморгает. Потом ему проще будет сказать "а хз", потому что да ну тут хрен поймешь что такое. А ведь код выше всего лишь икнременитрует счетчик типа `Counter`, и это все в хендлере хттп, вообще в другой области. То есть в совсем неожиданном месте очень неочевидный код инкрементации. Напомню, что инкремент обычно выглядит вот так `i++`.

Хотелось бы видеть что-то вот такое.

```go
store.UpdateCounter(20.1)
```

Во-первых это означает, что `store` будет ориентироваться на простые встроенные типы, без использования `Counter` и `Gauge`. И в дальнейшем я планирую вообще отказаться от использования этих типов, они мне кажется лишними

Так что я планирую изменить сигнатуры хранилища вот так:

```go
func UpdateCounter(ctx context.Context, name string, delta int64) (value int64, err error)

// а было вот так:
func SetCounter(name string, c Counter) 
```

Тут целая куча изменений:

+ Counter -> int64
+ возвращаемое значение появилось
+ Update вместо Set
+ мнемонически более правильно писать `delta`, чтобы быть целостней с `storage.Delta`
+ добавлен контекст
+ возвращаем новое значение счетчика в поле `value`(влияние json вариантов ответа)

### По поводу геттеров

Новая сигнатура такая

```go
func Counter(ctx context.Context, name string) (value int64, found bool, err error)
```

Получается аж три возвращаемых параметра. И все вот почему: если мы полагаемся на ошибку, то во-первых ошибку долго проверять, а во-вторых где мы объявим эту ошибку? Например, в `storage` если положить, то как-то странно получится. Мы опять привязались к `storage`. Если в каком-то другом месте, например в `api`, то как бы чего тут делают ошибки ввода-вывода, мы же высокоуровневая штука. Или нам в интерфейсе нужно требовать проверку ошибки...

Ну короче пока так

### Что в итоге?

#### Интерфейс `api.Operator`

По итогу интерфейс хранилища теперь хранится в `api`. Что безусловно фантастически удобно. Если мы меняем что-то в апи, то это хранилище должно под него меняться, а не наоборот, я считаю апи более высокоуровневым. И апи с итоге не зависит от хранилища, наоборот, оно **регулирует** каким должно быть хранилище.

#### Обработка пачкой, и класс данных

Хранилище теперь оперирует классом данных metrica.Metrica. Оно получает его на вход, и отдает на выход. Причем получает и отдает массив. Таким образом мы унифицировали интерфейс, такое подойдёт для всех вышестоящих функций, при этом сами данные в хранилище могут хранится вообще по-другому. Например, чего стоит обертка `OpetatorAdapter`, которая позволяет работать со старыми хранилищами, просто обрабатывая данные пачкой.

Почему пачкой? Потому что дальше у нас базы данных, и я хочу скрыть реализацию транзакций внутри этой обработки пачкой. Не хочу, чтобы хендлеры пользовались транзакциями и вообще знали о них. Круто, у нас получилась инкапсуляция :)

## Исходные мысли

### Что я вообще хочу от хранилища

ПО сути это у нас контроллер? Над моделями? Что этовообще за часть проги

Чтобы вся логика метрик была сконцентрирована тут по максимуму, чтобы если добавился новый тип счетчика, то можно было бы поменять тут пару или десяток строк и работать дальше, не боясь, что ещё что-то надо в сервере поменять и в агенте, и в репортере

Также можно сделать эту часть наиболее устойчивой, чтобы остальные компоненты могли от нее зависеть, в надежде, что ничего меняться не будет. Но все же хочется добавить гибкости моему приложению

### `Storager` - интерфейс хранилища. (ныне вынесен в api.Operator)

Сделан в стиле языка `Go`, метрики вызываются геттерами и сеттерами

```go
val,ok:=metrica.Counter("testCounter")
storage.SetCounter("testCounter", val)
// и аналогично Gauge, SetGauge
```

Если добавлять тип, нужно создавать новый интерфейс и новый тип, и ещё имплементировать Stringer для типа

```go
type NewType newtype

type NewTyper interface{
   NewTyper(name string)
   SetNewType(name string, value NewType)
   ListNewType() [string]
}

func (n NewType) String() string{

}// NewType должен поддерживать интерфейс Stringer теперь
```

И ещё добавить в конструктор, и ещё добавить поля в `MemStore`, короче тоже не просто все

В целом есть ощущение, что если уж мы создали наименование функций, то именованные типы (`Counter` вместо `int64`) кажутся **лишними**

## Исследование

Мне кажется, надо понимать, что рано или поздно мы переедем в базу данных, а значит надо

+ Пользоваться интерфейсом для хранилища
+ Организовывать данные соответсвенно

Возможно в функцию мы будем получать интерфейс сохранения объекта, но без указания в какой базе мы его держим

## Хранилище никак не знает ни о чем, оно умеет только хранить

### Хранилище только для одного типа данных. В марштрут мы передаем хранилище

```go
makeroute("/counter", NewStorage[int64](), counterHandler)

func counterHandler(storage,urlArgs){
    val=storage.ParseValue(string_from_request)
    storage.Add("name",val)
}
```

Тут можно использовать `Дженерики`

----

В итоге оказывается, что мы не можем передать дженерик интерфейс в функцию так `func Foo(s store)`, нам обязательно требудется указать тип так `func Foo(s store[int64])`, иначе будет ошибка на неиниализированный интерфейс. А это значит что для каждого маршрута придётся писать свою функцию обработчик со своей сигнатурой.

Или... подождите подождите, это должна быть дженерик функция тоже, такого типа

```go
func makeHandler(T any)(){
    return func(s[storage], w http.RepsonseWriter, r *http.Request)
}
```

А ведь неплохой вариант, блин. Единственное, непонятно, что будет когда доедем до базы данных. Видимо базе придется какие-то Dao-объекты делать для кадого типа, содержащие в себе замыкания... **Красиво, можно было бы попробовать.**

### Хранилище хранит разные типы данных, по сути нам нужен интерфейсный тип для данных, это гемор

```go
//использование Counter
Metric.Set[counter]()
Metric.Add[counter]()
Metric.Get[counter]()

//Хендлер маршрута
counterHandler():
    old_val,ok=storage["counter"]["testCounter"]
    storage["counter"]["testCounter"]=new(Counter)

```

Тут придется использовать `Интерфейсы`

> А можно написать и несколько версий-веток!

----
Тут главная проблема, что в интерфейсе не может быть дженерик методово, может быть дженерик только сам интерфейс
Это значит нужно или писать интерфейс для метрики, а её тоже потребуется инициализировать. Мы знаем только метод `SetString(valueFromRequest string)`,
который можно имплементировать без приведения типа, а где-то все равно придётся приводить тип из интерфейса

Нужно не забывать, что ещё существует задача проверки типа счетчика, когда приходит запрос, это ещё дополнительная загвозка

## Заключение

Мне кажется интересным способом было бы ещё воспользоваться паттерном из w.ResponseWriter()

```go
w.Header().Write()
w.Header().Get()
```

так у нас могло бы быть `metrica.Counter().Get()`, где

```go
func (m MemStorage) Counter() MetricStorage(int64){
    ...
}

type MetricStorage[T any] interface{
    Get() T
    Set(val T)
    Add(val T)
}

```

Получается такой гибрид итоговорого способа и первого экспериментального и раздела Исследование

----

Ещё один момент, по сути метрики это не только тип данных, но ещё и поведение, и конечно стоило бы выделить их в отдельный пакет, конечно, чтобы у них была функция вроде Process

metrics.Counter()

***-----***

Я думаю в конце мы можем сделать специальную кодогененирующую утилиту, которая будет собсно создавать код под новую метрику.

## Итог

Как все получилось на самом деле

----

По итогу этот исходный тезис о хранилище погиб, ему не суждено было жить. Мы могли бы думать о том, что хранилище умеет только хранить и получать данные из хранилища.

Но по сути, так мы смотрим на хранилище со стороны интерфейса хранилища. У нас же хранилища это контроллеры, они умеют подключаться к БД, они умеют работать с транзакциями. Они умеют сохраняться на диск, но с точки зрения интерфейса. Они умеют лишь читать и созранять.

И то это не совсем верно. В нашей задаче один из счетчиков имеет состояние. Это счетчик `Counter`, то есть хранилище умеет изменять это состояние.

По сути, с точки зрения интерфейса у меня лишь два метода `Read()` и `Update()`.

### Что дальше?

Хотелось бы как-то позаботится об `идемпотентности`, типа если я вот отправил значение счетчика, а потом отправил ещё раз, чтобы Counter не сложился бы дважды, например.

### Есть ли надежда на оптимизацию?

После нескольких исследований оказалось, что сравнение двух строк все равно быстрее, чем сравнение хешей строк. И что в мапе уже довольно хороший алгоритм хеширования.

Чисто теоретически направление оптимизации хранилища такие:

+ Самодельная мапа с убыстренным хешером, и может без проверки на коллизии. При условии, что мы имеем ограничеснный набор данных. Или предупреждающая о коллизии.
+ Держать хранилизе в стеке, и в идеале вообще в кеше процессора. Вот это красивая задачка. Для этого возможно объявить массив метрик, который будет лежать кучей рядом с мапой, а мапа будет держать ссылки в эту мапу. Интересно попробовать, и сравнить скорость))))

Правда все это упирается в то, что оптимизации уже не так чтобы очень важны. Особенно оптимизации хранилища в памяти, ведь мы переезжаем на БД. И там и так дофига проблем. И много вопросов к архитектуре
