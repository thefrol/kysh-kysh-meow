# Хранилище метрик

Содержит хранилище для памяти `MemStore`, типы счетчиков `Counter`, `Gauge` и интерфейс `Storager`

## Обновление 10.1

Очень странная ситуация возникла, что в хендлерах мы оперируем очень далекими от хендлеров классами - `Counter` и `Gauge`. Это создает кучу проблем с преобразованием типов. Хотя бы глянуть сюда

```go
old, _ := api.store.Counter(params.name)
new := old + metrica.Counter(value)
api.store.SetCounter(params.name, new)
```

Спроси у человека, что делаем код, он выпадет в осадок, потом пять минут потупит. Потом скорее всего ему проще будет сказать "а хз". А ведь код выше всего лишь икнременитрует счетчик типа `Counter`, и это все в хендлере хттп, вообще в другой области. В хендлере мы хотим видеть какой-то такой код

```go
store.UpdateCounter(20.1)
```

Во-первых это означает, что `store` будет ориентироваться на простые встроенные типы, без использования `Counter` и `Gauge`. И в дальнейшем я планирую вообще отказаться от использования этих типов, они мне кажется лишними

Так что я планирую изменить мигнатуры хранилища вот так:

```go
func UpdateCounter(ctx context.Context, name string, delta int64) (value int64, err error)

// а было вот так:
func SetCounter(name string, c Counter) 
```

Тут целая куча изменений:

+ Counter -> int64
+ возвращаемое значение появилось
+ Update вместо Set
+ мнемонически более правильно писать `delta`, чтобы быть целостней с `storage.Delta`
+ добавлен контекст
+ возвращаем новое значение счетчика в поле `value`(влияние json вариантов ответа)

### По поводу геттеров

Новая сигнатура такая

```go
func Counter(ctx context.Context, name string) (value int64, found bool, err error)
```

Получается аж три возвращаемых параметра. И все вот почему: если мы полагаемся на ошибку, то во-первых ошибку долго проверять, а во-вторых где мы будем хранить эту ошибку? Например, в `storage` если положить, то как-то странно получится. Мы опять привязались к `storage`. Если в каком-то другом месте, например в `api`, то как бы чего тут делают ошибки ввода-вывода, мы же высокоуровневая штука. Или нам в интерфейсе нужно требовать проверку ошибки...

Ну короче пока так

## Что я вообще хочу от хранилища

ПО сути это у нас контроллер? Над моделями? Что этовообще за часть проги

Чтобы вся логика метрик была сконцентрирована тут по максимуму, чтобы если добавился новый тип счетчика, то можно было бы поменять тут пару или десяток строк и работать дальше, не боясь, что ещё что-то надо в сервере поменять и в агенте, и в репортере

Также можно сделать эту часть наиболее устойчивой, чтобы остальные компоненты могли от нее зависеть, в надежде, что ничего меняться не будет. Но все же хочется добавить гибкости моему приложению

## `Storager` - интерфейс хранилища

Сделан в стиле языка `Go`, метрики вызываются геттерами и сеттерами

```go
val,ok:=metrica.Counter("testCounter")
storage.SetCounter("testCounter", val)
// и аналогично Gauge, SetGauge
```

Если добавлять тип, нужно создавать новый интерфейс и новый тип, и ещё имплементировать Stringer для типа

```go
type NewType newtype

type NewTyper interface{
   NewTyper(name string)
   SetNewType(name string, value NewType)
   ListNewType() [string]
}

func (n NewType) String() string{

}// NewType должен поддерживать интерфейс Stringer теперь
```

И ещё добавить в конструктор, и ещё добавить поля в `MemStore`, короче тоже не просто все

В целом есть ощущение, что если уж мы создали наименование функций, то именованные типы (`Counter` вместо `int64`) кажутся **лишними**


# Исследование

Мне кажется, надо понимать, что рано или поздно мы переедем в базу данных, а значит надо 
+ Пользоваться интерфейсом для хранилища
+ Организовывать данные соответсвенно

Возможно в функцию мы будем получать интерфейс сохранения объекта, но без указания в какой базе мы его держим

## Хранилище никак не знает ни о чем, оно умеет только хранить.

### Хранилище только для одного типа данных. В марштрут мы передаем хранилище

```go
makeroute("/counter", NewStorage[int64](), counterHandler)

func counterHandler(storage,urlArgs){
	val=storage.ParseValue(string_from_request)
	storage.Add("name",val)
}
```

Тут можно использовать `Дженерики`

----

В итоге оказывается, что мы не можем передать дженерик интерфейс в функцию так `func Foo(s store)`, нам обязательно требудется указать тип так `func Foo(s store[int64])`, иначе будет ошибка на неиниализированный интерфейс. А это значит что для каждого маршрута придётся писать свою функцию обработчик со своей сигнатурой.

Или... подождите подождите, это должна быть дженерик функция тоже, такого типа

```go
func makeHandler(T any)(){
	return func(s[storage], w http.RepsonseWriter, r *http.Request)
}
```

А ведь неплохой вариант, блин. Единственное, непонятно, что будет когда доедем до базы данных. Видимо базе придется какие-то Dao-объекты делать для кадого типа, содержащие в себе замыкания... **Красиво, можно было бы попробовать.** 

### Хранилище хранит разные типы данных, по сути нам нужен интерфейсный тип для данных, это гемор


```go
//использование Counter
Metric.Set[counter]()
Metric.Add[counter]()
Metric.Get[counter]()

//Хендлер маршрута
counterHandler():
	old_val,ok=storage["counter"]["testCounter"]
	storage["counter"]["testCounter"]=new(Counter)

```

Тут придется использовать `Интерфейсы`

> А можно написать и несколько версий-веток!

----
Тут главная проблема, что в интерфейсе не может быть дженерик методово, может быть дженерик только сам интерфейс
Это значит нужно или писать интерфейс для метрики, а её тоже потребуется инициализировать. Мы знаем только метод `SetString(valueFromRequest string)`,
который можно имплементировать без приведения типа, а где-то все равно придётся приводить тип из интерфейса 


Нужно не забывать, что ещё существует задача проверки типа счетчика, когда приходит запрос, это ещё дополнительная загвозка 

## Заключение

Мне кажется интересным способом было бы ещё воспользоваться паттерном из w.ResponseWriter()

```
w. Header().Write()
w.Header().Get()
```

так у нас могло бы быть `metrica.Counter().Get()`, где 

```
func (m MemStorage) Counter() MetricStorage(int64){
	...
}

type MetricStorage[T any] interface{
	Get() T
	Set(val T)
	Add(val T)
}

```

Получается такой гибрид итоговорого способа и первого экспериментального и раздела Исследование

----

Ещё один момент, по сути метрики это не только тип данных, но ещё и поведение, и конечно стоило бы выделить их в отдельный пакет, конечно, чтобы у них была функция вроде Process

metrics.Counter()

-----

Я думаю в конце мы можем сделать специальную кодогененирующую утилиту, которая будет собсно создавать код под новую метрику.
